\section{Conclusion}
\label{sec:conclusion}

\paragraph{Genesis}

The genesis of this dissertation traces back to 2014, when my supervisor Prof. Chung-Kil Hur ran a
seminar on CompCert~\cite{compcert}.  CompCert is exciting because it demonstrated formal semantics
and compiler verification research scale up to real-world applications.  One day, he asked what are
the concrete addresses of global variables in CompCert C, and I answered ``I don't know.''  So we
read CompCert code together, and realized that CompCert C does not assign concrete addresses to
global variables because it does not support cast between integers and pointers.  Then we started to
develop a formal semantics of the feature, which ended up being my first first-author
paper~\cite{intptrcast}.

It was exciting to advance the state-of-the-art of C formal semantics, and it naturally became my
dissertation topic.  I focused on low-level features because they are difficult to capture in a
formal semantics due to the conflict among many ``stakeholders.''  To understand them, I began to
read C/C++ standards, Linux kernel and LLVM mailing lists, and even architecture ISA manuals which I
didn't expect to do so at the beginning of my graduate school life.



\paragraph{Contributions}

As a result, we developed formal semantics of three low-level features of C crucially used in
systems programming, namely relaxed-memory concurrency, separate compilation, and cast between
integers and pointers.  Our semantics adequately balances the conflicting desiderata of programmers,
compilers, and hardware in that it $(1)$ supports the features' common usage patterns and reasoning
principles for programmers, and $(2)$ provably validates major compiler optimizations at the same
time.  To establish confidence in our formal semantics, we have formalized most of our key results
in Coq.


\paragraph{Impact}

Our formal semantics had concrete impacts on both academia and industry.  In academia, we and others
published follow-up papers that $(1)$ refine our semantics to account for more usage patterns and
compiler optimizations, $(2)$ provide more evidences that show our semantics serves programmers,
compilers, and hardware well, or $(3)$ apply the key idea of our semantics to other languages.  In
industry, $(1)$ we discovered bugs and proposed fixes to bugs in GCC, LLVM, and CompCert, $(2)$ we
provided informed opinions to the discussion on C/C++ and LLVM IR language standards, and $(3)$ our
verification technique was adopted in CompCert.



\paragraph{Future Work}

However, by Meyer's standard, where real success is ``changing the way the IT industry develops
software'', ``the story told in this article is one of glaring, unremitted and probably definitive
failure''~\cite{bertrand-meyer}.  CompCert is changing the way safety-critical software is
developed~\cite{compcert-avionics,compcert-nuclear}.  In the similar spirit, we would like our
semantics to help system programmers, thereby changing the way systems are developed in general.  To
this end, we would like to pursue the following directions for future work.

\begin{itemize}

\item \emph{Refining Semantics}: Our semantics, as well as all the other C formal semantics, does
  not capture all the real-world practices of low-level features and compiler optimizations.  While
  it is impossible to do so, it is crucial to capture at least widely used patterns and
  performance-critical optimizations.  Otherwise, industrial developers will not approve our
  semantics and consider it a ``toy'' language.  In order to do so, we need to clearly understand
  each low-level feature's motivation and use cases.

\item \emph{Standardizing Semantics}: Developing a semantics should take into account a lot of
  stakeholders, and thus discussion on the semantics can easily diverge to too many proposals.  For
  mainstream languages like C, C++, and LLVM IR, standardization process is introduced to help the
  discussion to converge to a consensus.  We should also propose our semantics to the
  standardization process, thereby exchanging informed opinions on the semantics.

\item \emph{Developing Tools}: It is unlikely that semantics alone improves the life of industrial
  developers, because semantics is a theoretical artifact while developers need practical tools that
  help them to design and implement programs, and catch and prevent bugs.  Thus it is crucial to
  develop such tools---including model checkers, static analyzers, and program logics---based on
  semantics and metatheory.

\end{itemize}



% As future work, by further pursuing the research agenda for the formalization of real-world practice
% of C semantics and compilers, we aim to provide clear, theoretically-informed, and
% practically-relevant C semantics and compilers that system programmers can immediately benefit from.
% If successful, our formal semantics will be able to replace the C dialects used in Linux and other
% systems.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
