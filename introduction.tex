\section{Introduction}
\label{sec:introduction}

\subsection{The Context: The C Programming Language}

\paragraph{C as a Hardware Abstraction}

The C programming language is the \emph{lingua franca} for systems programming, mainly due to its
two notable advantages: \emph{portability} and \emph{control} over hardware.  C is portable in that
C programs can be compiled and then executed in most of the existing hardware.  At the same time, C
has a precise control over hardware in that C allows programmers to access relatively low-level
hardware features such as memory layout and concurrency.  These advantages have attracted system
programmers for decades, resulting in a giant ecosystem around the C language itself and tools such
as optimizing compilers, linkers, and program analyzers.

C enjoys portability and control---seemingly conflicting properties---at the same time thanks to the
fact that it is a balanced abstraction over various hardware assembly languages.  If C were exposing
too much detail of hardware, then it would have not been able to support some assembly languages
that mismatch with the exposed details, losing a significant degree of portability; on the other
hand, if C were exposing too little detail of hardware, then it would have lost precise control over
them.  The design choice of C as a hardware abstraction is so popular that other systems programming
languages---such as C++, D, Objective C, Swift, Rust---largely follow the design of C and are often
called ``C-like''.

% To summarize, the C programming language is an abstraction that should satisfy the desiderata for
% three different ``masters'': portability for programmers, control for hardware, and optimization for
% compilers.

% C---like all the other programming languages---serves multiple ``masters'', namely programmers,
% compilers, and hardware.  From programmer's point of view, C should support \emph{reasoning
%   principles} that are powerful enough to reason about real-world C programs and guarantee their
% safety and functional correctness.  On the other hand, C should validate compiler and hardware
% \emph{optimizations} that may vastly accelerate the execution of C programs and are therefore
% actually performed in the real-world compilers and hardware.  What is particularly interesting about
% C is that TODO.


\paragraph{Compiler Optimization}

However, C is not just a thin wrapper around assembly languages because of compiler optimizations.
Compiler optimizations have been so crucial for the performance of systems since the early days that
every system programmer expect a compiler to perform, \eg{} register promotion and register
allocation~\cite{reg-prom, reg-alloc}, which are very effective and yet quite sophisticated compiler
optimizations.  Compiler optimizations are becoming more and more important these days because
recent trends offer potential for compiler optimizations to further improve the performance of
systems.  Since compiler optimizations are an essential ingredient of the real-world practice of C,
the language should be an abstraction not only over just hardware assembly languages but also over
compiler optimizations.

% system programmers are building bigger systems, which they cannot hand-optimize on their own; and
% hardware vendors are introducing complex features, which need a special attention for maximal
% utilization.

% These days the mainstream compilers are becoming so aggressive in these days that they are
% performing even subtle optimizations that cannot be immediately justified.

Some compiler optimizations are so subtle that they cannot be intuitively justified.  For example,
consider the following optimization that is actually performed by the mainstream compilers such as
GCC~\cite{gcc} and LLVM~\cite{llvm}:

\[\begin{array}{rcl}
\begin{minipage}{0.27\textwidth}
\begin{minted}{c}
void f() {
  10: int x = 42;
  20: g();
  30: print(x);
}
\end{minted}
\end{minipage}
&
\optarrow
&
\begin{minipage}{0.4\textwidth}
\begin{minted}{c}
void f() {
  10: int x = 42;
  20: g();
  30: print(42); // const. prop.
}
\end{minted}
\end{minipage}
\end{array}\]

\noindent Suppose \code{g()} is an external function whose body is unknown to the compiler, and
\code{print($x$)} prints the value of $x$ to the screen.  The function \code{f()} first assigns
\code{42} to \code{x} (line \code{10}), calls \code{g()} (line \code{20}), and then prints \code{x}
(line \code{30}).  Mainstream compilers replaces \code{x} with \code{42} at line \code{30},
effectively propagating the constant \code{42} at line \code{10} to line \code{30}.  Compilers
perform such a \emph{constant propagation} optimization because they analyze that the variable
\code{x} is accessible only within the function \code{f()}, since its address is not leaked to
elsewhere, and thus \code{g()} cannot modify the content of \code{x}.

But what if an adversarial \code{g()} tries to \emph{guess} the address of \code{x} as follows?
%
\[
\begin{minipage}{0.8\textwidth}
\begin{minted}{c}
void g() {
  10: int anchor;
  20: int *guess = &anchor + 10; // guessing &x
  30: *guess = 666;
}
\end{minted}
\end{minipage}
\]
%
\noindent The function \code{g()} tries to guess the address of \code{x} by exploiting the fact that
stack usually grows downwards: it first declares a variable \code{anchor}, and guesses that
\code{\&x} is 10 words bigger than \code{\&anchor}.  The guess happens to be correct when compiled
with GCC: indeed, when this \code{g()} is linked with the original \code{f()}, \code{f()} will
surprisingly print the evil value 666; on the other hand, when this \code{g()} is linked with the
optimized \code{f()}, \code{f()} will print the propagated value 42 as expected.\footnote{We got
  this result with GCC 8.2.1 and the compile option \code{-fno-stack-protector} in Linux 4.18.} This
example invalidates the compiler's analysis that \code{x} is accessible only within the function
\code{f()}, putting the soundness of the optimization in danger.

In order to rescue the constant propagation, C blames the adversarial code by marking it as invoking
\emph{undefined behavior}~\cite{undefined-behavior}: the function \code{g()} is not following the
rule of C so that compilers can do anything it chooses, even ``to make demons fly out of your
nose''~\cite{nasal-demons}.  Specifically, \code{g()} invokes undefined behavior in the ISO
C18~\cite{c18} because the pointer \code{guess} is outside of the valid range of the memory
allocation of \code{anchor}, from which $\code{guess}$ is derived from, and thus \code{guess} is an
invalid address~\cite{c11-6.5.6p8}.  In other words, compilers may safely assume that all the
pointers derived from \code{anchor} \emph{shall} point to \code{anchor}, because a failure to
conform with such an assumption invokes undefined behavior.

What is particularly interesting about C is the widespread use of undefined behavior in defining
language semantics.  The constant propagation example above shows that the low-level control over
memory layout conflicts with a simple compiler optimization, and C resolves the conflict by marking
adversarial programs as invoking undefined behavior.  C typically applies this strategy for
resolving the conflicts between control over various low-level details of hardware and various
compiler optimizations implemented in mainstream C compilers, introducing a lot of undefined
behavior instances in the language semantics.  It is worth comparing C with higher-level
languages---such as Java, .NET, OCaml, Haskell---that do not need undefined behaviors to justify
compiler optimizations thanks to their lack of precise control over low-level details of hardware,
\eg{} constant propagation is immediately justified in Haskell without resorting to undefined
behavior thanks to its lack of raw pointer.


\subsection{The Problem: Reckless Development of Semantics and Compilers}

The problem is that the C language and its compilers have evolved in such an unplanned way that even
experienced systems programmers disagree on the language semantics and the soundness of various
compiler optimizations.  In order to improve performance and energy consumption of systems, compiler
writers have introduced dozens of subtle optimizations even though their soundness is justified
solely by intuition; in turn, to justify those optimizations afterwards, the recent ISO C standards
mark more and more programs as invoking undefined behavior with a variety of ad-hoc exceptions,
making the already informal semantics more ambiguous and confusing.  In order to mitigate the
problem caused by reckless development of C semantics and compilers, ISO refines the C semantics in
a series of standards---C89, C99, C11, and C18---but they are still complex and are not widely
accepted in the systems programming community, \eg{} the Linux community defines its own dialect of
C that supports much less compiler optimizations and is closer to the assembly language than ISO
C18.

TODO: explain the problems in more details.  Too many undefined behaviors, conflicts among
optimizations.  ISO C18 is English prose.


\subsection{Prior Art: Formal Semantics and Compiler Verification}

In order to systematically address the problems caused by the unplanned evolution of C semantics and
compilers, researchers have proposed to \emph{define the formal semantics} of C and \emph{prove the
  soundness of compiler optimizations} w.r.t. the formal semantics.  In this research program, we
describe the C semantics no longer in an informal English prose but in a mathematically clear
formalization, thereby completely removing the ambiguity of semantics; furthermore, on top of the
formal semantics, we prove that compiler optimizations preserve the semantics of source program,
conclusively vindicating them from miscompilation bugs.

TODO: CompCert, Vellvm

TODO: only toy


\subsection{Our Contribution: Towards Formalization of C in the Wild}

In this dissertation, propose in several dimensions.

but we dealt very important and difficult aspects of C.


TODO: ``towards'': it's not the end.  in some sense, it's just a beginning...



\paragraph{Organization}

The rest of \Cref{chap:prologue} provides the technical background that informs the rest of the
dissertation.  \Cref{sec:background} explains more details of CompCert, based on which the main body
of this dissertation will be developed.  Specifically, we explain the formal semantics of C,
assembly languages, and intermediate representations (IR) of CompCert, and how it proves the
soundness of transformations and optimizations.

\paragraph*{}

The following chapters present the main contributions of this dissertation.
%
\begin{itemize}
\item \Cref{chap:intptrcast} proposes a semantics of \textbf{casts between integers and pointers}
  and, in the presence of the feature, how to verify compiler optimizations.  This chapter draws
  heavily on the work and writing in the following paper:

  \cite{intptrcast} \textbf{Jeehoon Kang}, Chung-Kil Hur, William Mansky, Dmitri Garbuzov, Steve
  Zdancewic, Viktor Vafeiadis.  \emph{A Formal C Memory Model Supporting Integer-Pointer Casts}.
  \textbf{PLDI 2015}.

\item \Cref{chap:promising} proposes a semantics of \textbf{relaxed-memory concurrency} and, in the
  presence of the feature, how to verify compiler optimizations.  This chapter draws heavily on the
  work and writing in the following paper:

  \cite{promising} \textbf{Jeehoon Kang}, Chung-Kil Hur, Ori Lahav, Viktor Vafeiadis, Derek Dreyer.
  \emph{A Promising Semantics for Relaxed-Memory Concurrency}.  \textbf{POPL 2017}.

\item \Cref{chap:sepcomp} proposes how to verify compiler in the presence of \emph{separate
    compilation}.  TODO: lightweight?  This chapter draws heavily on the work and writing in the
  following paper:

  \cite{sepcomp} \textbf{Jeehoon Kang}, Yoonseung Kim, Chung-Kil Hur, Derek Dreyer, Viktor
  Vafeiadis.  \emph{Lightweight Verification of Separate Compilation}.  \textbf{POPL 2016}.
\end{itemize}

This dissertation concludes with \Cref{chap:epilogue}, which summarizes the contributions and their
impacts (\Cref{sec:conclusion}) and future work (\Cref{sec:futurework}).


% TODO: how to mention these papers?
%
% \begin{itemize}
% \item[\cite{scfix}] Ori Lahav, Viktor Vafeiadis, \textbf{Jeehoon Kang}, Chung-Kil Hur, Derek Dreyer.
%   \emph{Repairing Sequential Consistency in C/C++11}.  \textbf{PLDI 2017}.
% \item[\cite{crellvm}] \textbf{Jeehoon Kang}*, Yoonseung Kim*, Youngju Song*, Juneyoung Lee, Sanghoon
%   Park, Mark Dongyeon Shin, Yonghyun Kim, Sungkeun Cho, Joonwon Choi, Chung-Kil Hur, Kwangkeun Yi.
%   (*The first three authors contributed equally and are listed alphabetically.)  \emph{Crellvm:
%     Verified Credible Compilation for LLVM}.  \textbf{PLDI 2018}.
% \end{itemize}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% TeX-command-extra-options: "-shell-escape"
%%% End:
